"""
回溯法
是一种通过遍历所有可能成员来寻找全部可行解的算法。
若候选 不是 可行解 (或者至少不是 最后一个 解)，
回溯法会在前一步进行一些修改以舍弃该候选，换而言之， 回溯 并再次尝试。
"""

"""
**************************************************
解决一个回溯问题，实际上就是一个决策树的遍历过程。
你只需要思考 3 个问题：
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件。               -> 要么路径全满,要么选择列表为空,没的选了。
**************************************************
def traceback(路径, 选择列表):
    if 满足结束条件:                   #结束条件：也就是到达决策树底层，无法再做选择的条件。->>>要么路径全满,要么选择列表为空
        result.add(路径)
        return
    for 选择 in 选择列表:           1      2 3 4 5            12  3 4 5         123    4 5        1234   5    12345   
        做选择                       # path.appned(选择i） 
        traceback(路径, new选择列表)     #traceback(path，选择列表-选择i),  ->确定第一个，进入下一个选择
        撤销选择                     #path.pop(选择i)
result = []
*********************************************
----------------------------
其核心就是 for 循环里面的递归，
在递归调用之前「做选择」，
在递归调用之后「撤销选择」
--------------------------------------------
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, new选择列表) #进入下一层决策树
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
-------------------------------------------
我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，
同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。


def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
******写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，
当触发「结束条件」时，将「路径」记入结果集。************
"""


# def add(x):
#     if x == 0:
#         return 0
#     else:
#         return add(x - 1)
#
#
# add(4)
""" D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D """

d = {}
d1 = d.setdefault('a',{})
print(d1 ,type(d1))