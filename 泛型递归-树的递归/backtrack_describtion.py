"""
解决一个回溯问题，实际上就是一个决策树的遍历过程。
你只需要思考 3 个问题：
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件。
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

其核心就是 for 循环里面的递归，
在递归调用之前「做选择」，
在递归调用之后「撤销选择」

for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表) #进入下一层决策树
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表

我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，
同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。


def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。
"""
